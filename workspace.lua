--[[
Workspace v2
  by LDDestroier

TO-DO:
 * figure out how to get the shell's running program for each workspace for the Notification function
 * add background or pattern to represent the "void" between workspaces
 * add ability to swap workspaces
 * add config file

--]]

if (_G.workspace_running) then
	print("Workspace is already running.")
	return true
end

-- keyDown key for either option key
keys.ctrl = 500
keys.alt = 501
keys.shift = 502

local config = {

	-- speed at which viewport scrolls by. range is between 0.001 and 1
	scroll_speed = 0.05,
	scroll_delay = 0.01,
	
	-- when opening a new workspace, open the file picker by default
	use_program_picker = false,
	
	-- default program when opening a new workspace
	default_program = "rom/programs/shell.lua",

	-- whether or not pausing is permitted
	allow_pausing = true,

	-- amount of time the workspace grid display is shown when it pops up
	osd_duration = 0.6,

	-- given names for specific programs to be written alongside the grid display
	program_titles = {
		["rom/programs/shell.lua"] = "Shell",
		["rom/programs/edit.lua"] = "Edit",
		["rom/programs/monitor.lua"] = "Monitor",
		["rom/programs/lua.lua"] = "Lua Interpreter",
		["rom/programs/gps.lua"] = "GPS",
		["rom/programs/fun/adventure.lua"] = "Adventure",
		["rom/programs/fun/dj.lua"] = "DJ",
		["rom/programs/fun/hello.lua"] = "Hello world!",
		["rom/programs/fun/speaker.lua"] = "Speaker",
		["rom/programs/fun/worm.lua"] = "Worm",
		["rom/programs/fun/advanced/gfxpaint.lua"] = "GFXPaint",
		["rom/programs/fun/advanced/raycast.lua"] = "Raycast Demo",
		["rom/programs/fun/advanced/redirection.lua"] = "Redirection",
		["rom/programs/fun/advanced/pngview.lua"] = "PNGView",
		["rom/programs/pocket/falling.lua"] = "Falling",
		["rom/programs/rednet/chat.lua"] = "Chat",

		["cash.lua"] = "Cash",
		["enchat3.lua"] = "Enchat 3",
		["ldris.lua"] = "LDris",
		["workspace.lua"] = "Workspace",
		["pain.lua"] = "PAIN",
		["stdgui.lua"] = "STD-GUI",
		["tron.lua"] = "Tron",
	}
}

-- events that require focus
local focus_events = {
	["key"] = true,
	["char"] = true,
	["key_up"] = true,
	["mouse_click"] = true,
	["mouse_drag"] = true,
	["mouse_up"] = true,
	["mouse_scroll"] = true,
	["paste"] = true,
	["terminate"] = true
}

-- instructs on using the program
local function showHelp()
	print("CTRL+SHIFT+Arrow to change space.")
	print("CTRL+SHIFT+[WASD] to add a space.")
	print("CTRL+SHIFT+Q to delete the current space.")
	print("CTRL+SHIFT+P to toggle pausing the space.")
	print("Terminate on an inactive space to quit.")
end

-- native versions of certian functions that are modified for each workspace
local og_func = {os = {}, term = {}, shell = {}}

-- global state
local state = {
	-- list of every workspace object, as generated by Workspace.Generate
	workspaces = {},
	count = 0,

	-- terminal size
	term_width = 1,
	term_height = 1,

	-- currently selected workspace in the grid
	x = 1,
	y = 1,

	-- scrolling across workspaces as a factor of terminal width/height
	-- 1 = no scroll, 2 = entire screen, 3 = two screen distances, etc.
	scroll_x = 1,
	scroll_y = 1,

	-- ensures that timer IDs are sequentially generated
	new_timer_id = os.startTimer(0),

	-- set this to true every time the layout of workspaces changes
	do_refresh = true,

	-- window object for notifications (defined in main)
	win_overlay = nil,
	overlay_visible = false,

	-- sentinal for entire program
	active = true
}

state.term_width, state.term_height = term.getSize()

local keysDown = {}
for i = 1, 256 do
	keysDown[i] = false
end

local function XYtoIndex(x, y)
	return tostring(x) .. "," .. tostring(y)
end

-- aligned write
function awrite(text, y, mode, win)
	win = win or term.current()
	local w_width, w_height = win.getSize()
	local cx, cy = win.getCursorPos()
	if (mode == "left") then
		win.setCursorPos(1, y or cy)
	
	elseif (mode == "right") then
		win.setCursorPos( w_width - text:len() + 1, y or cy)
	
	elseif (mode == "center") then
		win.setCursorPos( (w_width / 2) - math.floor(text:len() / 2) + 1, y or cy )
	end
	win.write(text)
end

-- centered write
function cwrite(text, y, win)
	return awrite(text, y, "center", win)
end

-- centered window reposition
function creposition(win, width, height)
	win.reposition(
		math.floor((state.term_width / 2) - (width / 2)) + 1,
		math.floor((state.term_height / 2) - (height / 2)) + 1,
		width,
		height
	)
end

function waitForKey(key)
	os.pullEvent()
	local evt, _key, _repeat
	while true do
		evt, _key, _repeat = os.pullEvent()
		if (evt == "key") then
			if (not key) or (key == _key) then
				return _key
			end

		elseif (evt == "term_resize") then
			return false
		end
	end
end

-- all workspace-related functions
local Workspace = {}

-- unmodified functions
og_func.os.clock = os.clock
og_func.os.startTimer = os.startTimer
og_func.os.clock = os.clock
og_func.os.time = os.time
og_func.os.queueEvent = os.queueEvent
og_func.term.redirect = term.redirect
og_func.term.native = term.native
og_func.term.setCursorPos = term.setCursorPos

Workspace.SetCustomFunctions = function(space)
	assert(type(space) == "table", "space must be a table")
	assert(type(space.env) == "table", "space.env isn't a table?")

	os.startTimer = function(duration)
		if type(duration) == "number" then
			state.new_timer_id = state.new_timer_id + 1
			space.timers[state.new_timer_id] = og_func.os.clock() + space.clock_mod + duration
			return state.new_timer_id

		else
			error("bad argument #1 (number expected, got " .. type(duration) .. ")", 2)
		end
	end
	
	os.cancelTimer = function(id)
		if type(id) == "number" then
			space.timers[id] = nil

		else
			error("bad argument #1 (number expected, got " .. type(id) .. ")", 2)
		end
	end
	
	os.clock = function()
		return og_func.os.clock() + space.clock_mod
	end
	
	os.time = function()
		return (og_func.os.time() + space.time_mod) % 24
	end

	os.queueEvent = function(evt, ...)
		if type(evt) == "string" then
			table.insert(space.queued_events, {evt, ...})

		else
			error("bad argument #1 (number expected, got " .. type(evt) .. ")", 2)
		end
	end

	term.native = function(...)
		return space.og_window
	end

	term.setCursorPos = function(x, y)
		og_func.term.setCursorPos(x, y)
		space.cursor[1] = x
		space.cursor[2] = y
	end

	os.__WS_SPACE = space
end

Workspace.ResetCustomFunctions = function()
	os.startTimer = og_func.os.startTimer
	os.cancelTimer = og_func.os.cancelTimer
	os.clock = og_func.os.clock
	os.time = og_func.os.time
	os.queueEvent = og_func.os.queueEvent
	term.native = og_func.term.native
	term.setCursorPos = og_func.term.setCursorPos
end

Workspace.DrawInactiveScreen = function(space)
	term.clear()
	term.setCursorBlink(false)
	local base_y = math.ceil(state.term_height / 2) - 2

	local ccolor = ((space.x + space.y) % 2 == 0) and colors.gray or colors.lightGray
	local cchar = "\127"

	term.setTextColor(ccolor)
	awrite(cchar:rep(5), 1, "left")
	awrite(cchar:rep(5), 1, "right")
	awrite(cchar:rep(5), state.term_height, "left")
	awrite(cchar:rep(5), state.term_height, "right")
	for y = 2, 4 do
		awrite(cchar, y, "left")
		awrite(cchar, y, "right")
	end
	for y = state.term_height - 3, state.term_height - 1 do
		awrite(cchar, y, "left")
		awrite(cchar, y, "right")
	end

	term.setTextColor(colors.white)

	cwrite("This workspace is inactive.", base_y)
	cwrite("Press Space to start workspace.", base_y + 1)
	cwrite("(" .. space.x .. ", " .. space.y .. ")", base_y + 3)
end

-- makes a new workspace object
Workspace.Generate = function(path, x, y, active)
	assert(type(x) == "number", "x must be number")
	assert(type(y) == "number", "y must be number")
	local space = {
		path = path,
		title = config.program_titles[path] or config.program_titles[fs.getName(path)] or fs.getName(path),
		x = x,
		y = y,
		env = {},
		paused = false,
		active = false,			-- false when waiting to start, true when running program
		allow_input = true,		-- when paused or unfocused, input is disallowed anyway
		start_on_program = active,	-- on creation, whether or not to launch the program immediately
		niceness = 0,			-- probably won't implement - influences how often the coroutine is resumed
		cursor = {0, 0},

		time_mod = 0,
		time_last = 0,
		clock_mod = 0,
		clock_last = 0,
		epoch_mod = 0,
		epoch_last = 0,
		timers = {},
		yield_return = {},
		queued_events = {},

		window = window.create(
			term.current(),
			1 + ((x - 1) * state.term_width),
			1 + ((y - 1) * state.term_height),
			state.term_width,
			state.term_height
		),
	}
	space.og_window = space.window
	local runProgram

	local callable = function(space)
		local status, err

		runProgram = function()
			space.active = true
			term.setTextColor(colors.white)
			term.setBackgroundColor(colors.black)
			term.clear()
			term.setCursorPos(1, 1)
			term.setCursorBlink(true)
			os.pullEvent()
			status, err = pcall(dofile, path)
			-- reset state
			space.queued_events = {}
			space.time_mod = 0
			space.time_last = 0
			space.clock_mod = 0
			space.clock_last = 0
			space.epoch_mod = 0
			space.epoch_last = 0
			space.timers = {}
		end
		
		if (space.start_on_program) then
			runProgram()
		end
		while true do
			space.active = false
			Workspace.DrawInactiveScreen(space)
			if ( waitForKey(keys.space) ) then
				runProgram()
			end
		end
	end

	setmetatable(space.env, {__index = _ENV})
	setfenv(callable, space.env)

	space.coroutine = coroutine.create(function()
		return callable(space)
	end)
	space.callable = callable
	return space
end

-- makes a workspace and adds it to the grid
Workspace.Add = function(path, x, y, active)
	assert(type(x) == "number", "X must be number")
	assert(type(y) == "number", "Y must be number")

	local key = XYtoIndex(x, y)
	if (not state.workspaces[key]) then
		state.workspaces[key] = Workspace.Generate(path, x, y, active)
		state.do_refresh = true
		state.count = state.count + 1
	end
	return state[key]
end

-- removes a workspace from the grid
Workspace.Remove = function(x, y)
	if (state.workspaces[XYtoIndex(x, y)]) then
		state.workspaces[XYtoIndex(x, y)] = nil
		state.do_refresh = true
		state.count = state.count - 1
	end
end

Workspace.CheckVisible = function(space)
	return (
		math.abs(space.x - state.scroll_x) <= 1 and
		math.abs(space.y - state.scroll_y) <= 1
	)
end

Workspace.PauseWorkspace = function(space, pause)
	if (space.paused == pause) then
		return
	end

	if (pause) then
		space.clock_last = os.clock() + space.clock_mod
		space.time_last = os.time() + space.time_mod
		space.epoch_last = os.epoch() + space.epoch_mod
		space.paused = true

	else
		space.clock_mod = space.clock_last - os.clock()
		space.time_mod = space.time_last - os.time()
		space.epoch_mod = space.epoch_last - os.epoch()
		space.paused = false
	end
end

Workspace.Notification = function(mode, option)
	if (mode == "pause") then
		local msg = option and "PAUSED" or "UNPAUSED"
		creposition(state.win_overlay, msg:len() + 2, 3, true)
		state.win_overlay.setVisible(true)
		state.overlay_visible = true
		state.win_overlay.setTextColor(colors.black)
		state.win_overlay.setBackgroundColor(colors.white)
		state.win_overlay.clear()
		cwrite(msg, 2, state.win_overlay)
	
	elseif (mode == "show_grid") then
		local max_x, max_y = 0, 0
		local min_x, min_y = math.huge, math.huge
		local win = state.win_overlay
		local x, y

		for key, space in pairs(state.workspaces) do
			max_x = math.max(max_x, space.x)
			max_y = math.max(max_y, space.y)
			min_x = math.min(min_x, space.x)
			min_y = math.min(min_y, space.y)
		end

		local space = state.workspaces[XYtoIndex(state.x, state.y)]
		local width
		if (space.active) then
			width = math.max(space.title:len() + 0, (max_x - min_x) + 3)
		else
			width = max_x - min_x + 3
		end

		creposition(state.win_overlay, width, (max_y - min_y) + 3)
		win.setVisible(true)
		state.overlay_visible = true
		win.setTextColor(colors.black)
		win.setBackgroundColor(colors.white)
		win.clear()

		if (space.title and space.active) then
			cwrite(space.title, 1, win)
		end

		y = 1
		for _y = min_y, max_y do
			y = y + 1
			x = math.floor((width / 2) - ((max_x - min_x) / 2))
			for _x = min_x, max_x do
				x = x + 1
				space = state.workspaces[XYtoIndex(_x, _y)]
				win.setCursorPos(x, y)
				if (space) then
					if (space.x == state.x and space.y == state.y) then
						win.setBackgroundColor(colors.lightGray)
					elseif space.active then
						win.setBackgroundColor(colors.gray)
					else
						win.setBackgroundColor(colors.black)
					end

					if space.paused then
						win.write("\7")
					else
						win.write(" ")
					end

				else
					win.setBackgroundColor(colors.white)
				end
			end
		end


	end

end

local function canRunWorkspace(space, evt, ignore_focus)
	-- never trust a programming teacher who tells you not to early return
	if (not evt) then
		return false
	end

	if (space.paused) then
		return false
	end

	if (focus_events[evt[1]] and (space.x ~= state.x or space.y ~= state.y) and (not ignore_focus)) then
		return false
	end

	if (space.yield_return[2] == nil) or (space.yield_return[2] == evt[1]) or (evt[1] == "terminate") then
		return true
	end

	return false
end

local function tryMoveViewport(x, y, do_skip)
	if (state.workspaces[XYtoIndex(state.x + x, state.y + y)]) then
		state.x = state.x + x
		state.y = state.y + y
		return true
	elseif (do_skip) then
		-- do some workspace skipping logic

	else
		return false
	end
end

local function main()
	state.active = true
	term.clear()

	for x = 1, 3 do
		for y = 1, 3 do
			Workspace.Add(config.default_program, x, y)
		end
	end

	state.x = 1
	state.y = 1
	state.workspaces[XYtoIndex(state.x, state.y)].start_on_program = true

	local evt = {}
	local timer_osd, timer_scroll, timer_tick
	timer_tick = os.startTimer(0)

	state.win_overlay = window.create(term.current(), 1, 1, 1, 1, false)

	-- in the loop, absolute window position of each workspace
	local space_absX, space_absY = 0, 0

	-- used as reference for fake timers
	local current_clock = os.clock()

	-- if true, redraw all visible windows
	local do_redraw = true

	-- if true, don't send the command keystrokes to the workspace
	local did_command = false

	-- reference for currently selected state
	local _space

	local c_term = term.current()

	while (state.active) do

		evt = {os.pullEventRaw()}

		_space = state.workspaces[XYtoIndex(state.x, state.y)]

		if (evt[1] == "key") then
			if (not evt[3]) then
				keysDown[ evt[2] ] = os.epoch()
				keysDown[ keys.ctrl ] = (keysDown[keys.leftCtrl] or keysDown[keys.rightCtrl])
				keysDown[ keys.alt ] = (keysDown[keys.leftAlt] or keysDown[keys.rightAlt])
				keysDown[ keys.shift ] = (keysDown[keys.leftShift] or keysDown[keys.rightShift])

				-- handle key combinations
				
				-- CTRL + SHIFT + ?
				if (keysDown[keys.ctrl] and keysDown[keys.shift]) then

					if (evt[2] == keys.right) then
						if tryMoveViewport(1, 0, true) then timer_scroll = os.startTimer(0) end
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true

					elseif (evt[2] == keys.left) then
						if tryMoveViewport(-1, 0, true) then timer_scroll = os.startTimer(0) end
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true

					elseif (evt[2] == keys.up) then
						if tryMoveViewport(0, -1, true) then timer_scroll = os.startTimer(0) end
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true

					elseif (evt[2] == keys.down) then
						if tryMoveViewport(0, 1, true) then timer_scroll = os.startTimer(0) end
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true

					elseif (evt[2] == keys.p) then
						if (_space.active) then
							Workspace.PauseWorkspace(_space, not _space.paused)
							Workspace.Notification("pause", _space.paused)
							timer_osd = os.startTimer(config.osd_duration)
							did_command = true
						end

					elseif (evt[2] == keys.w) then
						Workspace.Add(config.default_program, state.x, state.y - 1)
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true
						state.do_refresh = true
						do_redraw = true
					
					elseif (evt[2] == keys.s) then
						Workspace.Add(config.default_program, state.x, state.y + 1)
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true
						state.do_refresh = true
						do_redraw = true
					
					elseif (evt[2] == keys.a) then
						Workspace.Add(config.default_program, state.x - 1, state.y)
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true
						state.do_refresh = true
						do_redraw = true
					
					elseif (evt[2] == keys.d) then
						Workspace.Add(config.default_program, state.x + 1, state.y)
						Workspace.Notification("show_grid")
						timer_osd = os.startTimer(config.osd_duration)
						did_command = true
						state.do_refresh = true
						do_redraw = true
					
					elseif (evt[2] == keys.q) then
						if (state.count >= 2) then
							Workspace.Remove(state.x, state.y)
							if (state.workspaces[XYtoIndex(state.x - 1, state.y)]) then
								state.x = state.x - 1
								timer_scroll = os.startTimer(0) 

							elseif (state.workspaces[XYtoIndex(state.x + 1, state.y)]) then
								state.x = state.x + 1
								timer_scroll = os.startTimer(0) 

							elseif (state.workspaces[XYtoIndex(state.x, state.y - 1)]) then
								state.y = state.y - 1
								timer_scroll = os.startTimer(0) 

							elseif (state.workspaces[XYtoIndex(state.x, state.y + 1)]) then
								state.y = state.y + 1
								timer_scroll = os.startTimer(0) 

							else
								for key, space in pairs(state.workspaces) do
									state.x = space.x
									state.y = space.y
									break
								end
								timer_scroll = os.startTimer(0) 
							end

							Workspace.Notification("show_grid")
							timer_osd = os.startTimer(config.osd_duration)
							did_command = true
							state.do_refresh = true
							do_redraw = true
						end
					end
					
				end
			end

		elseif (evt[1] == "key_up") then
			keysDown[ evt[2] ] = false

		elseif (evt[1] == "timer") then
			if (evt[2] == timer_scroll) then
				if (state.x > state.scroll_x) then
					state.scroll_x = math.min(state.scroll_x + config.scroll_speed, state.x)
					timer_scroll = os.startTimer(config.scroll_delay)

				elseif (state.x < state.scroll_x) then
					state.scroll_x = math.max(state.scroll_x - config.scroll_speed, state.x)
					timer_scroll = os.startTimer(config.scroll_delay)
				end

				if (state.y > state.scroll_y) then
					state.scroll_y = math.min(state.scroll_y + config.scroll_speed, state.y)
					timer_scroll = os.startTimer(config.scroll_delay)

				elseif (state.y < state.scroll_y) then
					state.scroll_y = math.max(state.scroll_y - config.scroll_speed, state.y)
					timer_scroll = os.startTimer(config.scroll_delay)
				end
				do_redraw = true
			elseif (evt[2] == timer_tick) then
				timer_tick = os.startTimer(0)
--				state.win_overlay.redraw()

			elseif (evt[2] == timer_osd) then
				state.win_overlay.setVisible(false)
				state.overlay_visible = true
				do_redraw = true

			end

		elseif (evt[1] == "terminate") then
			if (state.workspaces[XYtoIndex(state.x, state.y)].active == false) then
				state.active = false
			end

		elseif (evt[1] == "term_resize") then
			state.term_width, state.term_height = term.getSize()
			state.do_refresh = true

		end

		current_clock = os.clock()

		-- iterate through all workspaces and do shit
		
		for key, space in pairs(state.workspaces) do

			-- handle terminal resizing
			space_absX = math.floor(1 + (space.x - state.scroll_x) * state.term_width)
			space_absY = math.floor(1 + (space.y - state.scroll_y) * state.term_height)
			if (state.do_refresh) then
				space.window.reposition(space_absX, space_absY, state.term_width, state.term_height)
			end

			-- handle fake timers
			for tID, tClock in pairs(space.timers) do
				if (tClock <= current_clock + space.clock_mod) then
					space.timers[tID] = nil
					table.insert(space.queued_events, {"timer", tID})
				end
			end

			-- handle manually queued events
			repeat
				if (space.queued_events[1]) then
					if (canRunWorkspace(space, space.queued_events[1], true)) then
						if (state.x == space.x and state.y == space.y) then
							space.window.restoreCursor()
--							space.window.setCursorBlink(true)
						end
						c_term = term.redirect(space.window)
						Workspace.SetCustomFunctions(space)
						space.yield_return = {coroutine.resume(space.coroutine, table.unpack(space.queued_events[1]))}
						Workspace.ResetCustomFunctions()
						term.redirect(c_term)
						table.remove(space.queued_events, 1)
					end
				end
			until (not canRunWorkspace(space, space.queued_events[1]))
			
			-- handle real events
			if not (did_command and (evt[1] == "key" or evt[1] == "char")) then
				if (canRunWorkspace(space, evt)) then
					if (state.x == space.x and state.y == space.y) then
						space.window.restoreCursor()
--						space.window.setCursorBlink(true)
					end
					c_term = term.redirect(space.window)
					Workspace.SetCustomFunctions(space)
					space.yield_return = {coroutine.resume(space.coroutine, table.unpack(evt))}
					Workspace.ResetCustomFunctions()
					term.redirect(c_term)
				end
			end

			-- reposition windows so they move like a real desktop grid
			if (Workspace.CheckVisible(space)) then
				space.window.setVisible(true)
				if (space.x == state.x and space.y == state.y) or (do_redraw) then
					if (space.x ~= state.scroll_x) or (space.y ~= state.scroll_y) or (do_redraw) then
						space.window.reposition(space_absX, space_absY)
					end
				end
			else
				space.window.setVisible(false)
			end

			if (state.overlay_visible) then
				state.win_overlay.redraw()
			end
		end

		do_redraw = false
		state.do_refresh = false
		did_command = false

	end

	return true
end

local function handleError(err)
	term.clear()
	term.setCursorPos(1, 1)
	printError(err)
end

-- :)
if math.random(1, 2^16) == 100 then
	printError("Fuck you, Curse of Ra")
	return false
end

local status, err

term.setBackgroundColor(colors.black)
term.setTextColor(colors.white)
term.setCursorPos(1, 1)
term.clear()
print("Welcome to Workspace!\n")
showHelp()
print("\nPress any key to continue.")
waitForKey()

_G.workspace_running = true

while (state.active) do
	status, err = pcall(main)
	if (not status) then
		state.active = false
		handleError(err)

	else
		term.clear()
		term.setCursorPos(1, 1)
		print("Thanks for using Workspace!")
	end
end

_G.workspace_running = false
